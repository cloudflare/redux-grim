{"version":3,"file":"redux-grim.es.min.js","sources":["../src/redux/addHooks.js","../src/util.js","../src/redux/makeActionCreator.js","../node_modules/seamless-immutable/seamless-immutable.development.js","../src/redux/makeReducer.js","../src/redux/actions.js","../src/normalization/constants.js","../src/normalization/resolveRule.js","../src/normalization/processRules.js","../src/normalization/createSelector.js","../src/normalization/denormalize.js","../src/normalization/normalizationReducer.js","../src/normalization/getNormalizerMiddleware.js","../src/normalization/normalize.js"],"sourcesContent":["// The actions and reducers created by makeAction and makeReducer share a common\n// method for modifying actions are reducer states: 'on'.\n// E.g. on('start, () => ...).\n//\n// 'on' callbacks are executed in the order they are added, and the first\n// parameter is the object to be modified (an action for makeAction, and the\n// new state for makeReducer). Each callback must return the object, or its\n// modified version, as callbacks are chained, the return value becoming the\n// first parameter of the next call.\n//\n\n/**\n * @param target {Object} - object to which the 'on' function will be added.\n * @param hooks {Object} - a object consisting of a set of initials functions.\n *  also defined which hooks are valid for 'on'.\n * @returns target - the original target, so allow easy chaining.\n */\nexport default function addHooks(target, hooks) {\n  target.on = (hook, fn) => {\n    if (!hook in hooks) throw `invalid hook ${hook}`;\n\n    const previousHook = hooks[hook];\n    if (previousHook) {\n      hooks[hook] = (first, ...rest) =>\n        fn(previousHook(first, ...rest), ...rest);\n    } else {\n      hooks[hook] = fn;\n    }\n    return target;\n  };\n}\n","const startExtension = '.start';\nconst successExtension = '.success';\nconst errorExtension = '.error';\nconst setExtension = '.set';\n\nexport const getStartType = entityType => `${entityType}${startExtension}`;\nexport const getSuccessType = entityType => `${entityType}${successExtension}`;\nexport const getErrorType = entityType => `${entityType}${errorExtension}`;\nexport const getSetType = entityType => `${entityType}${setExtension}`;\n\nexport const isStartType = type => type.endsWith(startExtension);\nexport const isSuccessType = type => type.endsWith(successExtension);\nexport const isErrorType = type => type.endsWith(errorExtension);\nexport const isSetType = type => type.endsWith(setExtension);\n","import addHooks from './addHooks';\nimport { getStartType, getSuccessType, getErrorType } from '../util';\n\nconst bodyMethods = ['put', 'patch', 'post'];\n\n// Regex to match the contents of () brackets\nconst parensReg = /\\(([^)]+)\\)/g; //\n\n// Regex to match the contents of [] brackets\nconst squareParensReg = /\\[([^)]+)\\]/g;\n\n// Actions can be modified using the 'on' method.\n// E.g. action.on('start', () => ..)\n//\n// This is a list of the possible values callback function is called with, and\n// the parameters they will be passed.\n// Each function must return the action, modified or otherwise.\n//\n// action - the action that was created by makeAction.\n// _namedParams - an object mapping from parameter name in the url to the value\n// that was passed to the action.\n// _restArgs - array of the rest of the params that were passed to the action.\n// _options - options object that was passed to makeAction\nconst defaultHooks = {\n  start: (action, _namedParams, _restArgs, _options) => action,\n  success: (action, _namedParams, _restArgs, _options) => action,\n  error: (action, _namedParams, _restArgs, _options) => action,\n  // All applies to start, success, and error actions\n  all: (action, _namedParams, _restArgs, _options) => action\n};\n\n// Some default behaviours when creating actions, that can be overridden.\n// apiFetch allows the fetch behaviour to be modified. restArgs - the parameters\n//  that were passed to the action after those specified by the url, are also\n//  passed to this function.\nconst defaultFunctions = {\n  apiFetch: (method, url, body, ..._rest) =>\n    // eslint-disable-next-line compat/compat\n    fetch(url, {\n      method: method.toUpperCase(),\n      body: JSON.stringify(body)\n    })\n};\n\n/**\n * Return true if the api and action functions require an object parameter\n * @param {String} method\n * @param {String} templateUrl\n * @returns boolean\n */\nfunction hasBodyParam(method, templateUrl) {\n  return (\n    bodyMethods.includes(method) ||\n    (method === 'delete' && templateUrl.includes('['))\n  );\n}\n\n/**\n * Extract an array of the named parameters in the url.\n *\n * E.g '/zone/(zoneId)/pool/[id]' -> ['zoneId', 'body'];\n *\n * If\n * @param {String} method\n * @param {String} templateUrl\n * @returns {Array}\n */\nexport function getNamedParameters(method, templateUrl) {\n  const params = new Set();\n  let match;\n  while ((match = parensReg.exec(templateUrl))) {\n    // Urls can reference the same object multiple times.\n    // E.g. /(zone.id)/(zone.organization.id)\n    // This will only add one named parameter to the array ('zone')\n    const str = match[1];\n    const periodIndex = str.indexOf('.');\n    params.add(periodIndex === -1 ? str : str.substr(0, str.indexOf('.')));\n  }\n  if (hasBodyParam(method, templateUrl)) {\n    params.add('body');\n  }\n  return params.size ? [...params] : [];\n}\n\n/**\n * Return a function that evaluates the url, using a params object to populate\n * the variable parts of the url.\n *\n * NOTE: Babel can't compile things that are inside of eval() or new Function(),\n * makeActionCreator() was using back-ticks (string templates) inside of new Function()\n * which busts IE11. So please use good old '+ foo +' in cases like this!\n *\n * E.g. const evaluate = makeUrlEvaluator('/zone/(zoneId)/pool/[id]');\n *      evaluate({ zoneId: 123, body: { id: 456 }})\n *      -> '/zone/123/create/456';\n *\n * @param {String} templateUrl\n * @returns {Function}\n */\nexport function makeUrlEvaluator(templateUrl) {\n  let url = templateUrl\n    // E.g. /(foo) -> /${params.foo}\n    .replace(parensReg, \"'+params.$1+'\")\n    // Adding empty [] to a delete url creates an action which takes a body param\n    .replace('[]', '')\n    // E.g. /[foo] -> /${params.body.foo}\n    .replace(squareParensReg, \"'+params.body.$1+'\");\n  return new Function('params', \"return '\" + url + \"';\");\n}\n\n/**\n * Returns a function which evaluates the tempalte url, with the action\n * arguments and returns an object containing the evaluated url, an object\n * mapping the named parameters to their actual values, and the rest of the\n * arguments supplied to the action.\n *\n * @param templateUrl {String}\n * @param namedParams {Array}\n * @returns {function}\n */\nexport function makeGetApiData(templateUrl, namedParams) {\n  const urlEvaluator = makeUrlEvaluator(templateUrl);\n\n  return (...args) => {\n    const params = namedParams.reduce((o, param, ii) => {\n      o[param] = args[ii];\n      return o;\n    }, {});\n\n    return {\n      url: urlEvaluator(params),\n      params,\n      restArgs: args.slice(namedParams.length)\n    };\n  };\n}\n\n/**\n * Create an asynchronous actions to access http resources.\n *\n * @param entityType {String} - used to create action types and match actions\n *   and reducers\n * @param method {String} - http method (get, post, etc)\n * @param templateUrl {String} - defines the url to access and the parameters\n *   which the action will accept. See the readme for for information.\n * @param options {Object} - An object which will be passed to the various\n *  hook functions. By default, this can only be used to log action creation,\n *  or a mismatch between expected parameters of an action and what is actually\n *  passed, by setting options = { debug: true }\n *\n */\nexport default function makeActionCreator(\n  entityType,\n  method,\n  templateUrl,\n  options = {}\n) {\n  const namedParams = getNamedParameters(method, templateUrl);\n  options.debug &&\n    logActionCreation(entityType, method, templateUrl, namedParams);\n\n  let mock;\n  const hooks = { ...defaultHooks };\n  const functions = { ...defaultFunctions };\n  const getApiData = makeGetApiData(templateUrl, namedParams);\n\n  const action = (...args) => async dispatch => {\n    if (options.debug) {\n      validateActionParameters(\n        entityType,\n        method,\n        templateUrl,\n        args,\n        namedParams\n      );\n    }\n\n    const { url, params, restArgs } = getApiData(...args);\n    let startAction = {\n      type: getStartType(entityType),\n      meta: {\n        entityType,\n        method\n      }\n    };\n    startAction = hooks.start(startAction, params, restArgs, options);\n    startAction = hooks.all(startAction, params, restArgs, options);\n    dispatch(startAction);\n\n    try {\n      let mockValue, response;\n      if (mock !== undefined) {\n        mockValue = typeof mock === 'function' ? mock(...args) : mock;\n        response = mockValue === undefined ? undefined : { body: mockValue };\n        response && console.info(`Mocking ${method} ${templateUrl}`, mockValue);\n      }\n      response =\n        response ||\n        (await functions.apiFetch(method, url, params.body, ...restArgs));\n\n      let successAction = {\n        type: getSuccessType(entityType),\n        payload: response && response.body,\n        meta: {\n          entityType,\n          method\n        }\n      };\n\n      successAction = hooks.success(\n        successAction,\n        params,\n        restArgs,\n        options,\n        response\n      );\n\n      successAction = hooks.all(\n        successAction,\n        params,\n        restArgs,\n        options,\n        response\n      );\n\n      const result = successAction.payload;\n      dispatch(successAction);\n      return result;\n    } catch (error) {\n      let errorAction = {\n        type: getErrorType(entityType),\n        payload: error,\n        error: true,\n        meta: {\n          entityType,\n          method\n        }\n      };\n      errorAction = hooks.error(errorAction, params, restArgs, options, error);\n      errorAction = hooks.all(errorAction, params, restArgs, options, error);\n      dispatch(errorAction);\n      throw error;\n    }\n  };\n\n  // All these functions return the action so they can be chained.\n  addHooks(action, hooks);\n  action.apiFetch = fn => ((functions.apiFetch = fn), action);\n  action.mock = fn => ((mock = fn), action);\n  action.unmock = () => ((mock = undefined), action);\n  return action;\n}\n\n/**\n * Called automatically when options = { debug: true }, to log information\n * about action creation.\n */\nexport function logActionCreation(entityType, method, url, namedParams) {\n  console.log(\n    `Created action ${entityType}, ${url}, ${method}(${namedParams.join(', ')})`\n  );\n}\n\n/**\n * Called automatically when options = { debug: true } to warn when there's\n * mismatch between the expected parameters of an action and what's actually\n * created.\n */\nexport function validateActionParameters(\n  entityType,\n  method,\n  url,\n  args,\n  namedParams\n) {\n  const hasBody =\n    url.indexOf('[') > -1 || ['post', 'put', 'patch'].includes(method);\n\n  // All parameters should be strings or numbers, unless there's a body, in\n  // which case the last parameter is an object.\n  if (args.length < namedParams.length) {\n    console.warn(\n      `For api call ${entityType}, ${method}, ${url},\n         Expected parameters: ${namedParams.join(', ')}\n         Actual parameters: ${args.join(', ')}\n      `\n    );\n  }\n  namedParams.forEach((param, ii) => {\n    const type = typeof args[ii];\n    if (hasBody && ii === namedParams.length - 1) {\n      if (type !== 'object') {\n        console.warn(\n          `${entityType}, ${method}, ${url}: Expected parameter ${param} to be an object. Actual value: ${\n            args[ii]\n          } ${type}`\n        );\n      }\n    } else if (type !== 'string' && type !== 'number') {\n      console.warn(\n        `${entityType}, ${method}, ${url}: Expected parameter ${param} to be a string or number. Actual value: ${\n          args[ii]\n        }`\n      );\n    }\n  });\n}\n","(function() {\n  \"use strict\";\n\nfunction immutableInit(config) {\n\n  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L21\n  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element');\n  var REACT_ELEMENT_TYPE_FALLBACK = 0xeac7;\n\n  var globalConfig = {\n    use_static: false\n  };\n  if (isObject(config)) {\n      if (config.use_static !== undefined) {\n          globalConfig.use_static = Boolean(config.use_static);\n      }\n  }\n\n  function isObject(data) {\n    return (\n      typeof data === 'object' &&\n      !Array.isArray(data) &&\n      data !== null\n    );\n  }\n\n  function instantiateEmptyObject(obj) {\n      var prototype = Object.getPrototypeOf(obj);\n      if (!prototype) {\n          return {};\n      } else {\n          return Object.create(prototype);\n      }\n  }\n\n  function addPropertyTo(target, methodName, value) {\n    Object.defineProperty(target, methodName, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    });\n  }\n\n  function banProperty(target, methodName) {\n    addPropertyTo(target, methodName, function() {\n      throw new ImmutableError(\"The \" + methodName +\n        \" method cannot be invoked on an Immutable data structure.\");\n    });\n  }\n\n  var immutabilityTag = \"__immutable_invariants_hold\";\n\n  function addImmutabilityTag(target) {\n    addPropertyTo(target, immutabilityTag, true);\n  }\n\n  function isImmutable(target) {\n    if (typeof target === \"object\") {\n      return target === null || Boolean(\n        Object.getOwnPropertyDescriptor(target, immutabilityTag)\n      );\n    } else {\n      // In JavaScript, only objects are even potentially mutable.\n      // strings, numbers, null, and undefined are all naturally immutable.\n      return true;\n    }\n  }\n\n  function isEqual(a, b) {\n    // Avoid false positives due to (NaN !== NaN) evaluating to true\n    return (a === b || (a !== a && b !== b));\n  }\n\n  function isMergableObject(target) {\n    return target !== null && typeof target === \"object\" && !(Array.isArray(target)) && !(target instanceof Date);\n  }\n\n  var mutatingObjectMethods = [\n    \"setPrototypeOf\"\n  ];\n\n  var nonMutatingObjectMethods = [\n    \"keys\"\n  ];\n\n  var mutatingArrayMethods = mutatingObjectMethods.concat([\n    \"push\", \"pop\", \"sort\", \"splice\", \"shift\", \"unshift\", \"reverse\"\n  ]);\n\n  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([\n    \"map\", \"filter\", \"slice\", \"concat\", \"reduce\", \"reduceRight\"\n  ]);\n\n  var mutatingDateMethods = mutatingObjectMethods.concat([\n    \"setDate\", \"setFullYear\", \"setHours\", \"setMilliseconds\", \"setMinutes\", \"setMonth\", \"setSeconds\",\n    \"setTime\", \"setUTCDate\", \"setUTCFullYear\", \"setUTCHours\", \"setUTCMilliseconds\", \"setUTCMinutes\",\n    \"setUTCMonth\", \"setUTCSeconds\", \"setYear\"\n  ]);\n\n  function ImmutableError(message) {\n    this.name = 'MyError';\n    this.message = message;\n    this.stack = (new Error()).stack;\n  }\n  ImmutableError.prototype = new Error();\n  ImmutableError.prototype.constructor = Error;\n\n  function makeImmutable(obj, bannedMethods) {\n    // Tag it so we can quickly tell it's immutable later.\n    addImmutabilityTag(obj);\n\n    if (\"development\" !== \"production\") {\n      // Make all mutating methods throw exceptions.\n      for (var index in bannedMethods) {\n        if (bannedMethods.hasOwnProperty(index)) {\n          banProperty(obj, bannedMethods[index]);\n        }\n      }\n\n      // Freeze it and return it.\n      Object.freeze(obj);\n    }\n\n    return obj;\n  }\n\n  function makeMethodReturnImmutable(obj, methodName) {\n    var currentMethod = obj[methodName];\n\n    addPropertyTo(obj, methodName, function() {\n      return Immutable(currentMethod.apply(obj, arguments));\n    });\n  }\n\n  function arraySet(idx, value, config) {\n    var deep          = config && config.deep;\n\n    if (idx in this) {\n      if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {\n        value = Immutable.merge(this[idx], value, {deep: true, mode: 'replace'});\n      }\n      if (isEqual(this[idx], value)) {\n        return this;\n      }\n    }\n\n    var mutable = asMutableArray.call(this);\n    mutable[idx] = Immutable(value);\n    return makeImmutableArray(mutable);\n  }\n\n  var immutableEmptyArray = Immutable([]);\n\n  function arraySetIn(pth, value, config) {\n    var head = pth[0];\n\n    if (pth.length === 1) {\n      return arraySet.call(this, head, value, config);\n    } else {\n      var tail = pth.slice(1);\n      var thisHead = this[head];\n      var newValue;\n\n      if (typeof(thisHead) === \"object\" && thisHead !== null) {\n        // Might (validly) be object or array\n        newValue = Immutable.setIn(thisHead, tail, value);\n      } else {\n        var nextHead = tail[0];\n        // If the next path part is a number, then we are setting into an array, else an object.\n        if (nextHead !== '' && isFinite(nextHead)) {\n          newValue = arraySetIn.call(immutableEmptyArray, tail, value);\n        } else {\n          newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n        }\n      }\n\n      if (head in this && thisHead === newValue) {\n        return this;\n      }\n\n      var mutable = asMutableArray.call(this);\n      mutable[head] = newValue;\n      return makeImmutableArray(mutable);\n    }\n  }\n\n  function makeImmutableArray(array) {\n    // Don't change their implementations, but wrap these functions to make sure\n    // they always return an immutable value.\n    for (var index in nonMutatingArrayMethods) {\n      if (nonMutatingArrayMethods.hasOwnProperty(index)) {\n        var methodName = nonMutatingArrayMethods[index];\n        makeMethodReturnImmutable(array, methodName);\n      }\n    }\n\n    if (!globalConfig.use_static) {\n      addPropertyTo(array, \"flatMap\",  flatMap);\n      addPropertyTo(array, \"asObject\", asObject);\n      addPropertyTo(array, \"asMutable\", asMutableArray);\n      addPropertyTo(array, \"set\", arraySet);\n      addPropertyTo(array, \"setIn\", arraySetIn);\n      addPropertyTo(array, \"update\", update);\n      addPropertyTo(array, \"updateIn\", updateIn);\n      addPropertyTo(array, \"getIn\", getIn);\n    }\n\n    for(var i = 0, length = array.length; i < length; i++) {\n      array[i] = Immutable(array[i]);\n    }\n\n    return makeImmutable(array, mutatingArrayMethods);\n  }\n\n  function makeImmutableDate(date) {\n    if (!globalConfig.use_static) {\n      addPropertyTo(date, \"asMutable\", asMutableDate);\n    }\n\n    return makeImmutable(date, mutatingDateMethods);\n  }\n\n  function asMutableDate() {\n    return new Date(this.getTime());\n  }\n\n  /**\n   * Effectively performs a map() over the elements in the array, using the\n   * provided iterator, except that whenever the iterator returns an array, that\n   * array's elements are added to the final result instead of the array itself.\n   *\n   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.\n   */\n  function flatMap(iterator) {\n    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    var result = [],\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var iteratorResult = iterator(this[index], index, this);\n\n      if (Array.isArray(iteratorResult)) {\n        // Concatenate Array results into the return value we're building up.\n        result.push.apply(result, iteratorResult);\n      } else {\n        // Handle non-Array results the same way map() does.\n        result.push(iteratorResult);\n      }\n    }\n\n    return makeImmutableArray(result);\n  }\n\n  /**\n   * Returns an Immutable copy of the object without the given keys included.\n   *\n   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.\n   */\n  function without(remove) {\n    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n    if (typeof remove === \"undefined\" && arguments.length === 0) {\n      return this;\n    }\n\n    if (typeof remove !== \"function\") {\n      // If we weren't given an array, use the arguments list.\n      var keysToRemoveArray = (Array.isArray(remove)) ?\n         remove.slice() : Array.prototype.slice.call(arguments);\n\n      // Convert numeric keys to strings since that's how they'll\n      // come from the enumeration of the object.\n      keysToRemoveArray.forEach(function(el, idx, arr) {\n        if(typeof(el) === \"number\") {\n          arr[idx] = el.toString();\n        }\n      });\n\n      remove = function(val, key) {\n        return keysToRemoveArray.indexOf(key) !== -1;\n      };\n    }\n\n    var result = instantiateEmptyObject(this);\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && remove(this[key], key) === false) {\n        result[key] = this[key];\n      }\n    }\n\n    return makeImmutableObject(result);\n  }\n\n  function asMutableArray(opts) {\n    var result = [], i, length;\n\n    if(opts && opts.deep) {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(asDeepMutable(this[i]));\n      }\n    } else {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(this[i]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function\n   * will return an array of two elements - the first representing a key, the other\n   * a value. Then returns an Immutable Object constructed of those keys and values.\n   *\n   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.\n   */\n  function asObject(iterator) {\n    // If no iterator was provided, assume the identity function\n    // (suggesting this array is already a list of key/value pairs.)\n    if (typeof iterator !== \"function\") {\n      iterator = function(value) { return value; };\n    }\n\n    var result = {},\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var pair  = iterator(this[index], index, this),\n          key   = pair[0],\n          value = pair[1];\n\n      result[key] = value;\n    }\n\n    return makeImmutableObject(result);\n  }\n\n  function asDeepMutable(obj) {\n    if (\n      (!obj) ||\n      (typeof obj !== 'object') ||\n      (!Object.getOwnPropertyDescriptor(obj, immutabilityTag)) ||\n      (obj instanceof Date)\n    ) { return obj; }\n    return Immutable.asMutable(obj, {deep: true});\n  }\n\n  function quickCopy(src, dest) {\n    for (var key in src) {\n      if (Object.getOwnPropertyDescriptor(src, key)) {\n        dest[key] = src[key];\n      }\n    }\n\n    return dest;\n  }\n\n  /**\n   * Returns an Immutable Object containing the properties and values of both\n   * this object and the provided object, prioritizing the provided object's\n   * values whenever the same key is present in both objects.\n   *\n   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.\n   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function\n   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.\n   */\n  function merge(other, config) {\n    // Calling .merge() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    if (other === null || (typeof other !== \"object\")) {\n      throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \" + JSON.stringify(other));\n    }\n\n    var receivedArray = (Array.isArray(other)),\n        deep          = config && config.deep,\n        mode          = config && config.mode || 'merge',\n        merger        = config && config.merger,\n        result;\n\n    // Use the given key to extract a value from the given object, then place\n    // that value in the result object under the same key. If that resulted\n    // in a change from this object's value at that key, set anyChanges = true.\n    function addToResult(currentObj, otherObj, key) {\n      var immutableValue = Immutable(otherObj[key]);\n      var mergerResult = merger && merger(currentObj[key], immutableValue, config);\n      var currentValue = currentObj[key];\n\n      if ((result !== undefined) ||\n        (mergerResult !== undefined) ||\n        (!currentObj.hasOwnProperty(key)) ||\n        !isEqual(immutableValue, currentValue)) {\n\n        var newValue;\n\n        if (mergerResult) {\n          newValue = mergerResult;\n        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {\n          newValue = Immutable.merge(currentValue, immutableValue, config);\n        } else {\n          newValue = immutableValue;\n        }\n\n        if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key)) {\n          if (result === undefined) {\n            // Make a shallow clone of the current object.\n            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));\n          }\n\n          result[key] = newValue;\n        }\n      }\n    }\n\n    function clearDroppedKeys(currentObj, otherObj) {\n      for (var key in currentObj) {\n        if (!otherObj.hasOwnProperty(key)) {\n          if (result === undefined) {\n            // Make a shallow clone of the current object.\n            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));\n          }\n          delete result[key];\n        }\n      }\n    }\n\n    var key;\n\n    // Achieve prioritization by overriding previous values that get in the way.\n    if (!receivedArray) {\n      // The most common use case: just merge one object into the existing one.\n      for (key in other) {\n        if (Object.getOwnPropertyDescriptor(other, key)) {\n          addToResult(this, other, key);\n        }\n      }\n      if (mode === 'replace') {\n        clearDroppedKeys(this, other);\n      }\n    } else {\n      // We also accept an Array\n      for (var index = 0, length = other.length; index < length; index++) {\n        var otherFromArray = other[index];\n\n        for (key in otherFromArray) {\n          if (otherFromArray.hasOwnProperty(key)) {\n            addToResult(result !== undefined ? result : this, otherFromArray, key);\n          }\n        }\n      }\n    }\n\n    if (result === undefined) {\n      return this;\n    } else {\n      return makeImmutableObject(result);\n    }\n  }\n\n  function objectReplace(value, config) {\n    var deep          = config && config.deep;\n\n    // Calling .replace() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    if (value === null || typeof value !== \"object\") {\n      throw new TypeError(\"Immutable#replace can only be invoked with objects or arrays, not \" + JSON.stringify(value));\n    }\n\n    return Immutable.merge(this, value, {deep: deep, mode: 'replace'});\n  }\n\n  var immutableEmptyObject = Immutable({});\n\n  function objectSetIn(path, value, config) {\n    if (!(Array.isArray(path)) || path.length === 0) {\n      throw new TypeError(\"The first argument to Immutable#setIn must be an array containing at least one \\\"key\\\" string.\");\n    }\n\n    var head = path[0];\n    if (path.length === 1) {\n      return objectSet.call(this, head, value, config);\n    }\n\n    var tail = path.slice(1);\n    var newValue;\n    var thisHead = this[head];\n\n    if (this.hasOwnProperty(head) && typeof(thisHead) === \"object\" && thisHead !== null) {\n      // Might (validly) be object or array\n      newValue = Immutable.setIn(thisHead, tail, value);\n    } else {\n      newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n    }\n\n    if (this.hasOwnProperty(head) && thisHead === newValue) {\n      return this;\n    }\n\n    var mutable = quickCopy(this, instantiateEmptyObject(this));\n    mutable[head] = newValue;\n    return makeImmutableObject(mutable);\n  }\n\n  function objectSet(property, value, config) {\n    var deep          = config && config.deep;\n\n    if (this.hasOwnProperty(property)) {\n      if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {\n        value = Immutable.merge(this[property], value, {deep: true, mode: 'replace'});\n      }\n      if (isEqual(this[property], value)) {\n        return this;\n      }\n    }\n\n    var mutable = quickCopy(this, instantiateEmptyObject(this));\n    mutable[property] = Immutable(value);\n    return makeImmutableObject(mutable);\n  }\n\n  function update(property, updater) {\n    var restArgs = Array.prototype.slice.call(arguments, 2);\n    var initialVal = this[property];\n    return Immutable.set(this, property, updater.apply(initialVal, [initialVal].concat(restArgs)));\n  }\n\n  function getInPath(obj, path) {\n    /*jshint eqnull:true */\n    for (var i = 0, l = path.length; obj != null && i < l; i++) {\n      obj = obj[path[i]];\n    }\n\n    return (i && i == l) ? obj : undefined;\n  }\n\n  function updateIn(path, updater) {\n    var restArgs = Array.prototype.slice.call(arguments, 2);\n    var initialVal = getInPath(this, path);\n\n    return Immutable.setIn(this, path, updater.apply(initialVal, [initialVal].concat(restArgs)));\n  }\n\n  function getIn(path, defaultValue) {\n    var value = getInPath(this, path);\n    return value === undefined ? defaultValue : value;\n  }\n\n  function asMutableObject(opts) {\n    var result = instantiateEmptyObject(this), key;\n\n    if(opts && opts.deep) {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = asDeepMutable(this[key]);\n        }\n      }\n    } else {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = this[key];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // Creates plain object to be used for cloning\n  function instantiatePlainObject() {\n    return {};\n  }\n\n  // Finalizes an object with immutable methods, freezes it, and returns it.\n  function makeImmutableObject(obj) {\n    if (!globalConfig.use_static) {\n      addPropertyTo(obj, \"merge\", merge);\n      addPropertyTo(obj, \"replace\", objectReplace);\n      addPropertyTo(obj, \"without\", without);\n      addPropertyTo(obj, \"asMutable\", asMutableObject);\n      addPropertyTo(obj, \"set\", objectSet);\n      addPropertyTo(obj, \"setIn\", objectSetIn);\n      addPropertyTo(obj, \"update\", update);\n      addPropertyTo(obj, \"updateIn\", updateIn);\n      addPropertyTo(obj, \"getIn\", getIn);\n    }\n\n    return makeImmutable(obj, mutatingObjectMethods);\n  }\n\n  // Returns true if object is a valid react element\n  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L326\n  function isReactElement(obj) {\n    return typeof obj === 'object' &&\n           obj !== null &&\n           (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);\n  }\n\n  function isFileObject(obj) {\n    return typeof File !== 'undefined' &&\n           obj instanceof File;\n  }\n\n  function isBlobObject(obj) {\n    return typeof Blob !== 'undefined' &&\n           obj instanceof Blob;\n  }\n\n  function isPromise(obj) {\n    return typeof obj === 'object' &&\n           typeof obj.then === 'function';\n  }\n\n  function isError(obj) {\n    return obj instanceof Error;\n  }\n\n  function Immutable(obj, options, stackRemaining) {\n    if (isImmutable(obj) || isReactElement(obj) || isFileObject(obj) || isBlobObject(obj) || isError(obj)) {\n      return obj;\n    } else if (isPromise(obj)) {\n      return obj.then(Immutable);\n    } else if (Array.isArray(obj)) {\n      return makeImmutableArray(obj.slice());\n    } else if (obj instanceof Date) {\n      return makeImmutableDate(new Date(obj.getTime()));\n    } else {\n      // Don't freeze the object we were given; make a clone and use that.\n      var prototype = options && options.prototype;\n      var instantiateEmptyObject =\n        (!prototype || prototype === Object.prototype) ?\n          instantiatePlainObject : (function() { return Object.create(prototype); });\n      var clone = instantiateEmptyObject();\n\n      if (\"development\" !== \"production\") {\n        /*jshint eqnull:true */\n        if (stackRemaining == null) {\n          stackRemaining = 64;\n        }\n        if (stackRemaining <= 0) {\n          throw new ImmutableError(\"Attempt to construct Immutable from a deeply nested object was detected.\" +\n            \" Have you tried to wrap an object with circular references (e.g. React element)?\" +\n            \" See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.\");\n        }\n        stackRemaining -= 1;\n      }\n\n      for (var key in obj) {\n        if (Object.getOwnPropertyDescriptor(obj, key)) {\n          clone[key] = Immutable(obj[key], undefined, stackRemaining);\n        }\n      }\n\n      return makeImmutableObject(clone);\n    }\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  function toStatic(fn) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      return fn.apply(self, args);\n    }\n\n    return staticWrapper;\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  // with the additional condition of choosing which function to call depending\n  // if argument is an array or an object.\n  function toStaticObjectOrArray(fnObject, fnArray) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      if (Array.isArray(self)) {\n          return fnArray.apply(self, args);\n      } else {\n          return fnObject.apply(self, args);\n      }\n    }\n\n    return staticWrapper;\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  // with the additional condition of choosing which function to call depending\n  // if argument is an array or an object or a date.\n  function toStaticObjectOrDateOrArray(fnObject, fnArray, fnDate) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      if (Array.isArray(self)) {\n          return fnArray.apply(self, args);\n      } else if (self instanceof Date) {\n          return fnDate.apply(self, args);\n      } else {\n          return fnObject.apply(self, args);\n      }\n    }\n\n    return staticWrapper;\n  }\n\n  // Export the library\n  Immutable.from           = Immutable;\n  Immutable.isImmutable    = isImmutable;\n  Immutable.ImmutableError = ImmutableError;\n  Immutable.merge          = toStatic(merge);\n  Immutable.replace        = toStatic(objectReplace);\n  Immutable.without        = toStatic(without);\n  Immutable.asMutable      = toStaticObjectOrDateOrArray(asMutableObject, asMutableArray, asMutableDate);\n  Immutable.set            = toStaticObjectOrArray(objectSet, arraySet);\n  Immutable.setIn          = toStaticObjectOrArray(objectSetIn, arraySetIn);\n  Immutable.update         = toStatic(update);\n  Immutable.updateIn       = toStatic(updateIn);\n  Immutable.getIn          = toStatic(getIn);\n  Immutable.flatMap        = toStatic(flatMap);\n  Immutable.asObject       = toStatic(asObject);\n  if (!globalConfig.use_static) {\n      Immutable.static = immutableInit({\n          use_static: true\n      });\n  }\n\n  Object.freeze(Immutable);\n\n  return Immutable;\n}\n\n  var Immutable = immutableInit();\n  /* istanbul ignore if */\n  if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return Immutable;\n    });\n  } else if (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n  }\n})();\n","import { static as Immutable } from 'seamless-immutable';\nimport addHooks from './addHooks';\nimport { getStartType, getSuccessType, getErrorType } from '../util';\n\nexport default function makeReducer(entityType, options = {}) {\n  const hooks = {\n    start: (nextState, _prevState, _action, _options) => nextState,\n    success: (nextState, _state, _action, _options) => nextState,\n    error: (nextState, _state, _action, _options) => nextState,\n    all: (nextState, _state, _action, _options) => nextState,\n    default: (state, _action, _options) => state\n  };\n\n  const startType = getStartType(entityType);\n  const successType = getSuccessType(entityType);\n  const errorType = getErrorType(entityType);\n\n  const dataKey = options.dataKey || 'data';\n  const errorKey = options.errorKey || 'error';\n  const isRequestingKey = options.isRequestingKey || 'isRequesting';\n  const isErroredKey = options.isErroredKey || 'isErrored';\n\n  let initialState = Immutable.from({\n    [dataKey]: undefined,\n    [errorKey]: null,\n    [isRequestingKey]: false,\n    [isErroredKey]: false\n  });\n\n  const reducer = (state = initialState, action) => {\n    let nextState;\n    switch (action.type) {\n      case startType:\n        nextState = {\n          ...state,\n          [isRequestingKey]: true,\n          [isErroredKey]: false,\n          [errorKey]: null\n        };\n\n        nextState = hooks.start(nextState, state, action, options);\n        nextState = hooks.all(nextState, state, action, options);\n        return Immutable.from(nextState);\n\n      case successType:\n        nextState = {\n          ...state,\n          [dataKey]: action.payload,\n          [isRequestingKey]: false,\n          [isErroredKey]: false\n        };\n\n        nextState = hooks.success(nextState, state, action, options);\n        nextState = hooks.all(nextState, state, action, options);\n        return Immutable.from(nextState);\n\n      case errorType:\n        nextState = {\n          ...state,\n          [isRequestingKey]: false,\n          [isErroredKey]: true,\n          [errorKey]: action.payload\n        };\n\n        nextState = hooks.error(nextState, state, action, options);\n        nextState = hooks.all(nextState, state, action, options);\n        return Immutable.from(nextState);\n\n      case `${entityType}.set`:\n        // Restrict the change to the data property\n        let path = ['data'];\n        if (action.meta.path) {\n          path = path.concat(action.meta.path);\n        }\n        return Immutable.setIn(state, path, action.payload);\n\n      case 'grim.reset':\n        const { includes, excludes } = action.payload;\n        if (includes) {\n          if (includes.includes(entityType)) {\n            return initialState;\n          }\n        } else if (!excludes || !excludes.includes(entityType)) {\n          return initialState;\n        }\n\n      default:\n        nextState = hooks.default\n          ? hooks.default(state, action, options)\n          : nextState;\n        return Immutable.from(nextState);\n    }\n  };\n\n  addHooks(reducer, hooks);\n  reducer.modifyInitialState = fn => (\n    (initialState = fn(initialState)), reducer\n  );\n\n  return reducer;\n}\n","import { getSetType } from '../util';\n\nexport function setAction(entityType, payload, path) {\n  return {\n    type: getSetType(entityType),\n    payload,\n    meta: {\n      entityType,\n      path\n    }\n  };\n}\n\nexport function resetAction({ includes, excludes } = {}) {\n  return {\n    type: 'grim.reset',\n    payload: {\n      excludes,\n      includes\n    }\n  };\n}\n","export const defaultId = 'id';\nexport const idProp = 'idProp';\nexport const targetProp = 'to';\nexport const propertiesProp = 'nestedProps';\n","import { targetProp, propertiesProp, idProp } from './constants';\n\n// If the rule has an alias, chain through all the rules to find the base rule.\nexport default function resolveRule(rules, type) {\n  let rule = rules[type];\n  let entityType = rule && type;\n\n  while (rule && rule[targetProp]) {\n    if (rule[idProp] || rule[propertiesProp]) {\n      throw `'${targetProp}' aliases cannot be used with '${idProp}' and '${propertiesProp}' properties`;\n    }\n    entityType = rule[targetProp];\n    rule = rules[rule[targetProp]];\n  }\n\n  return { entityType, rule };\n}\n","import { idProp, targetProp, propertiesProp } from './constants';\n\n// Very simple schema parsing, using typeof types.\n// propName: 'string' - propName must be defined and of type 'string'.\n// propName: 'number?' - propName may be undefined or have type number\n// propName: 'string{}' - propName must be defined, and is an object, every\n//   property of which must be a 'string'\n// propName: 'number{}?' - propName may be undefined or must be an object\n//   every property of which must be a 'number'\nconst configSchema = {\n  entityType: 'string',\n  [idProp]: 'string?',\n  [targetProp]: 'string?',\n  [propertiesProp]: 'string{}?'\n};\n\n// Used to split the schema descriptions.\n// E.g. 'abc{}?'.split(/(\\{\\})?(\\??)$/) -> [\"abc\", \"{}\", \"?\", \"\"];\nconst schemaRE = /(\\{\\})?(\\??)$/;\n\n// Verifies that every member of an array matches the specified schema, see\n// above.\nconst verifySchema = (arr, schema) =>\n  arr.every(obj => {\n    const keys = new Set([...Object.keys(configSchema), ...Object.keys(obj)]);\n    return Array.from(keys).every(propName => {\n      const schemaValue = schema[propName];\n      if (schemaValue === undefined) return;\n\n      const [schemaType, ...rest] = schemaValue.split(schemaRE);\n      const isOptional = rest.indexOf('?') > -1;\n      const isObject = rest.indexOf('{}') > -1;\n\n      const objValue = obj[propName];\n      const objType = typeof objValue;\n\n      if (isOptional && objValue === undefined) return true;\n\n      if (isObject) {\n        return (\n          objType === 'object' &&\n          Object.values(objValue).every(val => typeof val === schemaType)\n        );\n      }\n\n      return objValue !== undefined && typeof objType === schemaType;\n    });\n  });\n\nlet cachedRules;\nlet previousRules;\nlet previousLength;\n\nexport default function processRules(rules) {\n  if (\n    cachedRules &&\n    rules === previousRules &&\n    rules.length === previousLength\n  ) {\n    return cachedRules;\n  }\n\n  if (!verifySchema(rules, configSchema)) {\n    throw 'Error: rules do not match schema';\n  }\n\n  cachedRules = rules.reduce((o, rule) => ((o[rule.entityType] = rule), o), {});\n  previousRules = rules;\n  previousLength = rules.length;\n  return cachedRules;\n}\n","import { static as Immutable } from 'seamless-immutable';\nimport resolveRule from './resolveRule';\nimport denormalize from './denormalize';\nimport processRules from './processRules';\nimport { propertiesProp } from './constants';\n\n/**\n * Test if two arrays are the same, or contain the same contents\n */\nexport function arrayEquals(arr1, arr2) {\n  return (\n    arr1 === arr2 ||\n    (arr1 &&\n      arr2 &&\n      arr1.length === arr2.length &&\n      arr1.every((item, ii) => item === arr2[ii]))\n  );\n}\n\n/**\n * Build an array of all dependant entity types.\n * Note: This doesn't handle cyclic dependencies. Please don't introduce any.\n */\nexport function getEntityTypes(rules, type) {\n  const { rule, entityType } = resolveRule(rules, type);\n  let entityTypes = entityType && [entityType];\n  if (rule && rule[propertiesProp]) {\n    for (const key of Object.values(rule[propertiesProp])) {\n      entityTypes = [...entityTypes, ...getEntityTypes(rules, key)];\n    }\n  }\n  return entityTypes;\n}\n\n/**\n * Creates a memoized selector which returns denormalized objects.\n *\n * @param rules {object} optional - Describes how objects are normalized\n * @param entitiesSelector {function} - selector function which takes the state\n *   and returns the part of the state tree where normalized entity data lives.\n * @param entityType {string} - the type of the entity being selected\n * @param selector {function} - selector function. See below.\n * @returns a memoized selector function which returns denormalized entities.\n *\n * The selector parameter is a function which takes the state and resolves to\n * one of three types:\n * 1. an id.\n *    The entity selector returns the object corresponding to the id\n * 2. an array of ids\n *    The entity selector returns array of objects corresponding to the array of\n *    ids\n * 3. an object whose properties map to ids\n *    The entity selector returns an object whose properties map to the\n *    corresponding objects.\n *\n * Note: The selector parameter function can return either the id directly\n * or an object with a data property (because we use the format {\n *   data: id,\n *   isRequesting: true\n *   errors: [...]\n * }) where the value of the data property is the id, array of ids etc\n */\nexport default function createSelector(\n  arrayRules,\n  entitiesSelector,\n  entityType,\n  selector\n) {\n  const rules = processRules(arrayRules);\n  if (!rules[entityType]) throw `Key not found ${entityType}`;\n  const keys = [...new Set(getEntityTypes(rules, entityType))];\n\n  const selectors = [\n    // Only create a dependency on the normalized id (the data property of the\n    // object in the store for most cases).\n    state => {\n      const selection = selector(state);\n      const isObject = selection && typeof selection === 'object';\n\n      // This was a bad design decision. It's the only direct link with how\n      // objects are stored with Grim. Ideally the selector passed should\n      // point to the data property directly.\n      return isObject && 'data' in selection ? selection.data : selection;\n    },\n    // Turn keys into selectors\n    ...keys.map(key => state => entitiesSelector(state)[key])\n  ];\n\n  let lastSelected;\n  let lastDenormalized;\n\n  return state => {\n    const selected = selectors.map(selector => selector(state));\n    if (!arrayEquals(selected, lastSelected)) {\n      lastSelected = selected;\n      lastDenormalized = Immutable.from(\n        denormalize(rules, entityType, selected[0], entitiesSelector(state))\n      );\n    }\n    return lastDenormalized;\n  };\n}\n","import resolveRule from './resolveRule';\nimport { propertiesProp } from './constants';\n/**\n * @param {Object} rules - object specifying how entities are\n *   normalized\n * @param {id | Array[id] | object} id - Item or items to be denormalised\n * @oaram {String} entityType - key indicating the type of the normalized id/ids\n * @param {Object} state - The part of the state tree mapping from\n *   entityType => id => to the  entity data\n *\n * @return Denormalized object, or the original id parameter unchanged.\n */\nexport default function denormalize(rules, entityType, id, state) {\n  if (!id) return id;\n\n  const { rule, entityType: type } = resolveRule(rules, entityType);\n\n  if (Array.isArray(id)) {\n    return id.map(id => denormalize(rules, type, id, state));\n  }\n\n  // Denormalize an object - treat it as a map and denormalize the values\n  if (typeof id === 'object') {\n    return Object.entries(id).reduce((obj, [prop, id]) => {\n      obj[prop] = denormalize(rules, type, id, state);\n      return obj;\n    }, {});\n  }\n\n  const stateEntity = state[type] && state[type][id];\n\n  // The entity data may not exist in the state (it may be fetched by a separate\n  // endpoint) in which case just return the id.\n  if (!stateEntity) return id;\n\n  const entity = { ...stateEntity };\n\n  // Denormalize any child properties specified by the rule\n  if (rule[propertiesProp]) {\n    for (const [prop, type] of Object.entries(rule[propertiesProp])) {\n      entity[prop] = denormalize(rules, type, entity[prop], state);\n    }\n  }\n\n  return entity;\n}\n","import { static as Immutable } from 'seamless-immutable';\n\n// Updates entities in response to any action with response.entities.\n// Depends on the normalizerMiddelware\nexport default function normalizationReducer(state = {}, { meta }) {\n  if (meta) {\n    if (meta.method === 'delete') {\n      if (state[meta.entityType] && meta.id) {\n        // Only a single item can be deleted at a time.\n        return Immutable.set(\n          state,\n          meta.entityType,\n          Immutable.without(state[meta.entityType], meta.id)\n        );\n      }\n    } else if (meta.entities && typeof meta.entities === 'object') {\n      // Using seamless-immutable's deep merge resulted in an issue where an\n      // entity was supposed to have had a set of associated objects removed\n      // by setting the property to an empty object, but the deep merge retained\n      // those objects.\n      // Instead each entity type is merged separately using a shallow merge,\n      // which effectively replaces rather than merges individual entities.\n      let nextState = state;\n      Object.keys(meta.entities).forEach(\n        entityType =>\n          (nextState = Immutable.set(\n            nextState,\n            entityType,\n            Immutable.merge({}, [\n              state[entityType] || {},\n              meta.entities[entityType]\n            ])\n          ))\n      );\n      return nextState;\n    }\n  }\n  return state;\n}\n","import normalize from './normalize';\nimport processRules from './processRules';\nimport { isSuccessType, isSetType } from '../util';\n\n/**\n * Create Redux middleware function which normalizes entities\n */\nexport default function getNormalizerMiddleware(arrayRules, callback) {\n  const rules = processRules(arrayRules);\n  return () => next => action => {\n    // Only normalize success actions\n    if (isSuccessType(action.type) || isSetType(action.type)) {\n      // entityType is added by autogenerated actions. Normalization only applies\n      // to autogenerated components.\n      const { payload, meta } = action;\n      const entityType = meta && meta.entityType;\n      if (entityType && payload && rules[entityType]) {\n        meta.entities = {};\n        action.payload = normalize(rules, entityType, payload, meta.entities);\n        callback && callback(entityType, payload);\n      }\n    }\n    return next(action);\n  };\n}\n","import resolveRule from './resolveRule';\nimport { idProp as idField, defaultId, propertiesProp } from './constants';\n\n/**\n * @param {Object} rules - object specifying how entities are\n *   normalized\n * @oaram {String} entityType - the type of the object\n * @param {Object | Array} obj - The object, or array of objects to normalize.\n *  If the object has no id, it's assumed that all the properties of the object\n *  are the objects (of the same type), to normalize.\n * @param {Object} state - an object which will be populated with properties\n *   mapping from entityType => ids => object\n *\n * @return {number | Array | Object } - an id, or array of ids, or an object\n *  whose properties map to ids.\n */\nexport default function normalize(rules, entityType, obj, state) {\n  if (!rules[entityType]) throw `Unrecognised entityType: ${entityType}`;\n\n  const { rule, entityType: type } = resolveRule(rules, entityType);\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => normalize(rules, type, item, state));\n  }\n\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const idProp = rule[idField] || defaultId;\n  const id = obj[idProp];\n\n  if (!id) {\n    return Object.entries(obj).reduce((o, [prop, item]) => {\n      o[prop] = normalize(rules, type, item, state);\n      return o;\n    }, {});\n  }\n\n  const entity = { ...obj };\n  state[type] = state[type] || {};\n  state[type][id] = entity;\n\n  if (rule[propertiesProp]) {\n    for (const [prop, type] of Object.entries(rule[propertiesProp])) {\n      entity[prop] = normalize(rules, type, obj[prop], state);\n    }\n  }\n\n  return id;\n}\n"],"names":["addHooks","target","hooks","on","hook","fn","previousHook","first","rest","getStartType","entityType","getSuccessType","getErrorType","getSetType","isSuccessType","type","endsWith","isSetType","bodyMethods","parensReg","squareParensReg","defaultHooks","start","action","_namedParams","_restArgs","_options","success","error","all","defaultFunctions","apiFetch","method","url","body","fetch","toUpperCase","JSON","stringify","getNamedParameters","templateUrl","match","params","Set","exec","str","periodIndex","indexOf","add","substr","includes","hasBodyParam","size","makeGetApiData","namedParams","urlEvaluator","replace","Function","makeUrlEvaluator","args","reduce","o","param","ii","restArgs","slice","length","makeActionCreator","mock","options","debug","console","log","join","logActionCreation","functions","getApiData","dispatch","validateActionParameters","startAction","meta","undefined","mockValue","response","info","successAction","payload","result","errorAction","unmock","hasBody","warn","forEach","Immutable","immutableInit","config","data","REACT_ELEMENT_TYPE","Symbol","for","REACT_ELEMENT_TYPE_FALLBACK","globalConfig","use_static","instantiateEmptyObject","obj","prototype","Object","getPrototypeOf","create","addPropertyTo","methodName","value","defineProperty","enumerable","configurable","writable","banProperty","ImmutableError","Array","isArray","Boolean","immutabilityTag","isImmutable","getOwnPropertyDescriptor","isEqual","a","b","isMergableObject","Date","mutatingObjectMethods","mutatingArrayMethods","concat","nonMutatingArrayMethods","mutatingDateMethods","message","this","name","stack","Error","makeImmutable","bannedMethods","index","hasOwnProperty","freeze","makeMethodReturnImmutable","currentMethod","apply","arguments","arraySet","idx","deep","merge","mode","mutable","asMutableArray","call","makeImmutableArray","constructor","immutableEmptyArray","arraySetIn","pth","head","newValue","tail","thisHead","setIn","nextHead","isFinite","objectSetIn","immutableEmptyObject","array","flatMap","asObject","update","updateIn","getIn","i","asMutableDate","getTime","iterator","iteratorResult","push","without","remove","keysToRemoveArray","el","arr","toString","val","key","makeImmutableObject","opts","asDeepMutable","pair","asMutable","quickCopy","src","dest","other","TypeError","receivedArray","merger","addToResult","currentObj","otherObj","immutableValue","mergerResult","currentValue","otherFromArray","clearDroppedKeys","objectReplace","fnObject","fnArray","fnDate","path","objectSet","property","updater","initialVal","set","getInPath","l","defaultValue","asMutableObject","instantiatePlainObject","stackRemaining","$$typeof","isReactElement","File","isFileObject","Blob","isBlobObject","isError","then","isPromise","date","clone","toStatic","self","shift","toStaticObjectOrArray","from","static","module","makeReducer","nextState","_prevState","_action","_state","state","startType","successType","errorType","dataKey","errorKey","isRequestingKey","isErroredKey","initialState","reducer","excludes","modifyInitialState","setAction","resetAction","defaultId","idProp","targetProp","propertiesProp","resolveRule","rules","rule","cachedRules","previousRules","previousLength","configSchema","schemaRE","verifySchema","schema","every","keys","propName","schemaValue","split","schemaType","isOptional","isObject","objValue","objType","values","_typeof","processRules","createSelector","arrayRules","entitiesSelector","selector","lastSelected","lastDenormalized","getEntityTypes","entityTypes","selectors","selection","map","arr1","arr2","selected","item","denormalize","id","entries","prop","stateEntity","entity","normalizationReducer","entities","getNormalizerMiddleware","callback","next","normalize","idField"],"mappings":"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"}